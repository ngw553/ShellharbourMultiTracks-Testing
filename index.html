<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Shellharbour City Anglican Multitrack Player</title>
<style>
  :root {
    --bg:#0f1115; --panel:#151821; --panel2:#1b2030; --text:#e7e9ee; --muted:#9aa3b2;
    --accent:#74c0fc; --accent2:#a78bfa; --danger:#ff6b6b; --ok:#51cf66; --border:#23283a;
  }
  * { box-sizing: border-box; }
  body { margin:0; background:var(--bg); color:var(--text); font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  .wrap { max-width:1100px; margin:0 auto; padding:24px 16px 40px; }
  h1 { margin:0 0 8px; font-size:28px; font-weight:700; letter-spacing:.2px; }
  p.lead { margin:0 0 18px; color:var(--muted); }
  .songs { display:flex; flex-wrap:wrap; gap:8px; margin:16px 0 18px; }
  .song-btn {
    border:1px solid var(--border); background:linear-gradient(180deg,var(--panel),var(--panel2));
    color:var(--text); padding:10px 14px; border-radius:12px; cursor:pointer; transition:transform .06s ease, border-color .2s ease;
  }
  .song-btn:hover { transform: translateY(-1px); border-color:#2c3350; }
  .song-btn.active { outline:2px solid var(--accent); border-color:transparent; }
  .toolbar {
    display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px;
  }
  .toolbar .group { display:flex; gap:8px; align-items:center; }
  .btn {
    background:var(--panel2); border:1px solid var(--border); color:var(--text);
    padding:10px 12px; border-radius:10px; cursor:pointer; min-width:44px; text-align:center;
  }
  .btn:hover { border-color:#313852; }
  .btn.primary { background:linear-gradient(180deg,#24314a,#1d2740); border-color:#2a3551; }
  .btn.danger { background:linear-gradient(180deg,#3a1f27,#301a22); border-color:#4b1e26; color:#ffd7dc; }
  .toggle { display:flex; align-items:center; gap:8px; }
  .time { margin-left:auto; font-variant-numeric: tabular-nums; color:#c6cee0 }
  .seek { appearance:none; width:100%; height:10px; border-radius:999px; background:#22283b; outline:none; }
  .seek::-webkit-slider-thumb{ appearance:none; width:18px; height:18px; border-radius:50%; background:var(--accent); cursor:pointer; border:2px solid #0b0f1c; }
  .seek::-moz-range-thumb{ width:18px; height:18px; border:0; border-radius:50%; background:var(--accent); cursor:pointer; }
  .panel {
    background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px; margin-top:14px;
  }
  .tracks { display:flex; flex-direction:column; gap:10px; }

  /* Track row + waveform row */
  .track {
    display:grid;
    grid-template-columns: 220px 1fr auto;
    grid-auto-rows: auto;
    gap:12px;
    align-items:center;
    background:linear-gradient(180deg,var(--panel),#121724);
    border:1px solid var(--border); border-radius:12px; padding:10px;
  }
  .t-name { font-weight:600; color:#e9ecf5; }
  .t-controls { display:flex; gap:10px; align-items:center; }
  .t-controls .pill {
    background:var(--panel2); border:1px solid var(--border); border-radius:999px; padding:8px 12px; color:#e8ebf6; min-width:52px; text-align:center; cursor:pointer;
  }
  .t-controls .pill.active { outline:2px solid var(--accent2); }
  .t-slider { display:flex; align-items:center; gap:10px; color:#c8d0e2 }
  .t-slider input[type="range"]{ width:200px; }
  .master { display:flex; gap:12px; align-items:center; color:#c8d0e2 }
  small.hint { color:var(--muted); }
  .hidden { display:none; }

  /* Waveform container spans full width */
  .t-wave {
    grid-column: 1 / -1;
    height: 64px;
    background: #131827;
    border:1px solid #1e2440;
    border-radius: 10px;
    overflow: hidden;
  }

  /* Vertical VU meter */
  .vu {
    width: 10px;
    height: 36px;
    background: #1c2237;
    border:1px solid #283152;
    border-radius: 4px;
    position: relative;
    overflow: hidden;
  }
  .vu-fill {
    position: absolute;
    bottom: 0; left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(180deg, var(--ok), #88e08f);
    transition: height .06s linear;
  }

  /* Mobile */
  @media (max-width: 780px) {
    .track { grid-template-columns: 1fr; gap:8px; }
    .t-slider input[type="range"]{ width:100%; }
    .t-controls { flex-wrap:wrap; }
    .btn { padding:12px 14px; }
    .t-wave { height: 56px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <img src="sccac_logo-full-white.webp" alt="Shellharbour City Anglican Church Logo" style="max-width:50%; height:auto; display:block; margin:0 auto;"  />
  <h1>Shellharbour City Anglican Multitrack Player</h1>
  <p class="lead">Click a song to load. <b>The first song will load automatically.</b> If you click multiple times while the song is loading, the tracks will load multiple times. Use <b>Solo/Mute</b> and per-track <b>Volume</b>. Space = Play/Pause.</p>

  <!-- SONG BUTTONS -->
  <div class="songs" id="songButtons"></div>

  <!-- TRANSPORT / MASTER -->
  <div class="toolbar panel">
    <div class="group">
      <button id="playBtn" class="btn primary" title="Play (Space)">▶</button>
      <button id="pauseBtn" class="btn" title="Pause (Space)">⏸</button>
      <button id="stopBtn" class="btn" title="Stop (Ctrl+S)">⏹</button>
      <button id="toggleWaveBtn" class="btn" title="Show/Hide Waveforms">Waveforms On</button>
    </div>
    <div class="group master">
      <span>Master</span>
      <input id="masterVol" type="range" min="0" max="1" step="0.01" value="1" />
    </div>
    <label class="toggle group" title="Loop">
      <input id="loopToggle" type="checkbox" />
      <span>Loop</span>
    </label>
    <div class="time" id="timeDisplay">00:00 / 00:00</div>
  </div>

  <!-- SEEK BAR -->
  <div class="panel">
    <input id="seek" class="seek" type="range" min="0" max="1" step="0.001" value="0" />
    <div class="group" style="justify-content:space-between; margin-top:6px">
      <small class="hint">Drag to scrub</small>
      <small class="hint" id="loadHint">Load a song to begin</small>
    </div>
  </div>

  <!-- TRACKS LIST -->
  <div id="tracks" class="tracks panel"></div>

  <p class="lead" style="margin-top:18px">If you have any questions, issues or suggestions, please contact Nick Wilson.</p>
  <p class="lead" style="margin-top:15px">V2.2</p>
</div>

<!-- Pin WaveSurfer to v6 (UMD) so API is stable -->
<script src="https://unpkg.com/wavesurfer.js@6/dist/wavesurfer.min.js"></script>

<script>
/* ─────────────────────────────────────────────────────────────────────────────
   CONFIG
   ───────────────────────────────────────────────────────────────────────────── */
const SONGS = {
  "Hail The King": {
    folder: "HailTheKing",
    stems: [
      { file: "Drums.mp3",  name: "Drums" },
      { file: "Bass.mp3",   name: "Bass" },
      { file: "Guitar.mp3", name: "Acoustic Guitar" },
      { file: "Piano.mp3",  name: "Piano" },
      { file: "Violin.mp3", name: "Violin" },
      { file: "Vocal.mp3",  name: "Vocal" },
      { file: "Electric Guitar.mp3", name: "Electric Guitar" },
      { file: "Click.mp3",  name: "Click", muted: true }
    ]
  }
};

/* ─────────────────────────────────────────────────────────────────────────────
   AUDIO ENGINE
   ───────────────────────────────────────────────────────────────────────────── */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

let tracks = []; // { name, buffer, gainNode, analyser, _td, _meterFill, ws, volume, mute, solo, _source }
let masterGain = audioCtx.createGain();
masterGain.gain.value = 1;
masterGain.connect(audioCtx.destination);

let isPlaying = false;
let playStartedAt = 0;
let pausedAt = 0;
let duration = 0;
let raf = null;
let currentSongKey = null;

const el = {
  songButtons: document.getElementById('songButtons'),
  tracks: document.getElementById('tracks'),
  playBtn: document.getElementById('playBtn'),
  pauseBtn: document.getElementById('pauseBtn'),
  stopBtn: document.getElementById('stopBtn'),
  masterVol: document.getElementById('masterVol'),
  loopToggle: document.getElementById('loopToggle'),
  seek: document.getElementById('seek'),
  timeDisplay: document.getElementById('timeDisplay'),
  loadHint: document.getElementById('loadHint'),
};

// Build song buttons
for (const key of Object.keys(SONGS)) {
  const b = document.createElement('button');
  b.className = 'song-btn';
  b.textContent = key;
  b.addEventListener('click', () => loadSong(key, b));
  el.songButtons.appendChild(b);
}

el.masterVol.addEventListener('input', ()=> masterGain.gain.value = parseFloat(el.masterVol.value));
el.playBtn.addEventListener('click', ()=> { if (tracks.length) startPlayback(); });
el.pauseBtn.addEventListener('click', ()=> pausePlayback());
el.stopBtn.addEventListener('click', ()=> stopPlayback());

el.seek.addEventListener('input', (e)=>{
  const val = parseFloat(e.target.value);
  pausedAt = val;
  if (isPlaying) {
    createSources(pausedAt);
  } else {
    updateTimeDisplay();
    updateVisuals(pausedAt);
  }
});

window.addEventListener('keydown', e=>{
  if (e.code === 'Space') { e.preventDefault(); if (isPlaying) pausePlayback(); else startPlayback(); }
  if (e.code === 'KeyS' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); stopPlayback(); }
});

// Helpers
function formatTime(s){
  if (!isFinite(s) || s<=0) return '00:00';
  const m = Math.floor(s/60);
  const ss = Math.floor(s%60).toString().padStart(2,'0');
  return `${m}:${ss}`;
}

function startRaf(){
  if (raf) return;
  (function tick(){
    const pos = isPlaying ? (audioCtx.currentTime - playStartedAt) : pausedAt;
    el.seek.value = Math.min(pos, duration);
    updateTimeDisplay();
    updateVisuals(pos);

    if (isPlaying && el.loopToggle.checked && pos >= duration) {
      createSources(0);
    }
    raf = requestAnimationFrame(tick);
  })();
}
function stopRaf(){ if (raf) cancelAnimationFrame(raf); raf = null; }

function updateTimeDisplay(){
  const pos = isPlaying ? (audioCtx.currentTime - playStartedAt) : pausedAt;
  el.timeDisplay.textContent = `${formatTime(pos)} / ${formatTime(duration)}`;
}

/* Waveforms + meters */
function updateVisuals(pos){
  // Waveforms: keep in sync with playhead
  tracks.forEach(t => {
    if (!t.ws || !t.buffer || !isFinite(pos)) return;
    const dur = t.buffer.duration || duration || 1;
    const ratio = Math.max(0, Math.min(1, pos / dur));
    // WaveSurfer v6 uses seekTo(0..1)
    try { t.ws.seekTo(ratio); } catch(e){}
  });

  // Meters: post-gain RMS
  tracks.forEach(t => {
    if (!t.analyser || !t._td || !t._meterFill) return;
    t.analyser.getByteTimeDomainData(t._td); // 0..255 centered ~128
    let sumSq = 0;
    for (let i = 0; i < t._td.length; i++) {
      const v = (t._td[i] - 128) / 128;
      sumSq += v * v;
    }
    const rms = Math.sqrt(sumSq / t._td.length); // ~0..1
    t._meterSmooth = t._meterSmooth === undefined ? rms : (t._meterSmooth * 0.8 + rms * 0.2);
    const scale = 6; // simple multiplier to expand meter (adjust if needed)
    const pct = Math.min(100, Math.max(0, t._meterSmooth * scale * 100));
    t._meterFill.style.height = pct + "%";
  });
}

function stopSources(){
  tracks.forEach(t=>{
    if (t._source) {
      try { t._source.stop(0); } catch(e){}
      t._source.disconnect?.();
      t._source = null;
    }
  });
  isPlaying = false;
  stopRaf();
}

function createSources(atOffset=0){
  stopSources();
  const when = audioCtx.currentTime + 0.03;
  tracks.forEach(t=>{
    if (!t.buffer || atOffset >= t.buffer.duration) { t._source = null; return; }
    const src = audioCtx.createBufferSource();
    src.buffer = t.buffer;
    src.connect(t.gainNode);
    src.start(when, atOffset);
    t._source = src;
    t._startWhen = when;
    t._startOffset = atOffset;
  });
  playStartedAt = when - atOffset;
  isPlaying = true;
  startRaf();
}

function startPlayback(){
  if (!tracks.length) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  createSources(pausedAt);
}
function pausePlayback(){
  if (!isPlaying) return;
  const now = audioCtx.currentTime;
  pausedAt = now - playStartedAt;
  stopSources();
  updateVisuals(pausedAt);
}
function stopPlayback(){
  stopSources();
  pausedAt = 0;
  el.seek.value = 0;
  updateTimeDisplay();
  updateVisuals(0);
}

/* ─────────────────────────────────────────────────────────────────────────────
   TRACK UI
   ───────────────────────────────────────────────────────────────────────────── */

// Track Colours for the waveforms
const TRACK_COLORS = [
  '#4e74ff', // Blue
  '#ff6b6b', // Red
  '#51cf66', // Green
  '#f59f00', // Orange
  '#9c5eff', // Purple
  '#00b4d8', // Cyan
  '#ff9f1c', // Yellow-Orange
  '#ff61a6', // Pink
  '#2ec4b6', // Teal
  '#ff922b', // Amber
  '#845ef7', // Violet
  '#ff495c'  // Coral
];
  
function renderTracks(){
  el.tracks.innerHTML = '';
  tracks.forEach((t) => {
    const row = document.createElement('div');
    row.className = 'track';

    const name = document.createElement('div');
    name.className = 't-name';
    name.textContent = t.name;

    const controls = document.createElement('div');
    controls.className = 't-controls';

    const btnSolo = document.createElement('div');
    btnSolo.className = 'pill';
    btnSolo.textContent = 'Solo';
    btnSolo.addEventListener('click', ()=>{
      t.solo = !t.solo;
      btnSolo.classList.toggle('active', t.solo);
      updateGains();
    });

    const btnMute = document.createElement('div');
    btnMute.className = 'pill';
    btnMute.textContent = 'Mute';
    btnMute.addEventListener('click', ()=>{
      t.mute = !t.mute;
      btnMute.classList.toggle('active', t.mute);
      updateGains();
    });

    controls.append(btnSolo, btnMute);

    const volWrap = document.createElement('div');
    volWrap.className = 't-slider';
    const volLabel = document.createElement('span');
    volLabel.textContent = 'Vol';
    const vol = document.createElement('input');
    vol.type = 'range'; vol.min = '0'; vol.max = '1'; vol.step = '0.01'; vol.value = t.volume.toString();
    const volVal = document.createElement('span');
    volVal.textContent = Math.round(t.volume*100)+'%';
    vol.addEventListener('input', ()=>{
      t.volume = parseFloat(vol.value);
      volVal.textContent = Math.round(t.volume*100)+'%';
      updateGains();
    });

    // VU meter
    const vu = document.createElement('div');
    vu.className = 'vu';
    const vuFill = document.createElement('div');
    vuFill.className = 'vu-fill';
    vu.appendChild(vuFill);

    volWrap.append(volLabel, vol, volVal, vu);

    // Waveform container
    const waveWrap = document.createElement('div');
    waveWrap.className = 't-wave';

    row.append(name, controls, volWrap, waveWrap);
    el.tracks.appendChild(row);

    // Save elements
    t._el = { row, btnSolo, btnMute, vol, waveWrap, vuFill };
    t._meterFill = vuFill;

    // Create WaveSurfer for visual-only waveform
    try {
      if (window.WaveSurfer) {
        const ws = WaveSurfer.create({
          container: waveWrap,
          waveColor: TRACK_COLORS[i % TRACK_COLORS.length],
          progressColor: '#9caeff',
          cursorColor: '#ffffff',
          cursorWidth: 1,
          height: 64,
          interact: false,
          normalize: true,
          minPxPerSec: 80,   // enables auto-scroll
          autoScroll: true,
          autoCenter: true,
        });
        // Load via URL (stable across versions)
        ws.load(t._url);
        t.ws = ws;
      }
    } catch (e) {
      console.error('WaveSurfer error on', t.name, e);
    }

    // reflect initial state
    btnSolo.classList.toggle('active', t.solo);
    btnMute.classList.toggle('active', t.mute);
  });
}

function updateGains(){
  const anySolo = tracks.some(t => t.solo);
  tracks.forEach(t => {
    const g = t.gainNode;
    if (!g) return;
    const vol = t.volume;
    let target = vol;
    if (anySolo) target = t.solo ? vol : 0;
    if (t.mute) target = 0;
    g.gain.value = target;
  });
}

/* ─────────────────────────────────────────────────────────────────────────────
   SONG LOADING
   ───────────────────────────────────────────────────────────────────────────── */
async function fetchArrayBuffer(url){
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Fetch failed: ${url}`);
  return await res.arrayBuffer();
}
async function decodeAudio(arrBuf){
  return new Promise((resolve, reject) => {
    audioCtx.decodeAudioData(arrBuf, resolve, reject);
  });
}

async function loadSong(songKey, buttonEl){
  // Destroy any existing waveforms
  tracks.forEach(t => { try { t.ws && t.ws.destroy && t.ws.destroy(); } catch(e){} });

  document.querySelectorAll('.song-btn').forEach(b => b.classList.remove('active'));
  if (buttonEl) buttonEl.classList.add('active');

  stopPlayback();
  stopSources();
  tracks = [];
  el.tracks.innerHTML = '';
  el.loadHint.textContent = `Loading "${songKey}"…`;

  const cfg = SONGS[songKey];
  if (!cfg) return;

  const folder = cfg.folder.replace(/\/+$/,'');
  let maxDur = 0;

  for (const stem of cfg.stems) {
    // Encode filenames with spaces/special chars for GitHub Pages
    const url = `${folder}/${encodeURIComponent(stem.file)}`;
    try {
      const arr = await fetchArrayBuffer(url);
      const buffer = await decodeAudio(arr);

      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024; // time-domain length
      analyser.smoothingTimeConstant = 0.6;

      const gainNode = audioCtx.createGain();
      gainNode.gain.value = 1;

      // Route: gain -> analyser -> master
      gainNode.connect(analyser);
      analyser.connect(masterGain);

      const track = {
        name: stem.name || stem.file,
        file: stem.file,
        _url: url,               // for WaveSurfer.load
        buffer,
        gainNode,
        analyser,
        _td: new Uint8Array(analyser.fftSize),
        _meterFill: null,
        ws: null,
        volume: 1,
        mute: !!stem.muted,
        solo: false,
        _source: null
      };

      // Initial mute state
      gainNode.gain.value = track.mute ? 0 : 1;

      tracks.push(track);
      maxDur = Math.max(maxDur, buffer.duration);
    } catch (err) {
      console.error('Error loading stem:', url, err);
      tracks.push({
        name: (stem.name || stem.file) + ' (missing)',
        file: stem.file,
        _url: url,
        buffer: null,
        gainNode: null,
        analyser: null,
        _td: null,
        _meterFill: null,
        ws: null,
        volume: 0,
        mute: true,
        solo: false,
        _source: null
      });
    }
  }

  duration = maxDur || 0;
  el.seek.max = duration || 1;
  pausedAt = 0;

  renderTracks();
  updateGains();
  updateTimeDisplay();
  updateVisuals(0);

  el.loadHint.textContent = `Loaded "${songKey}".`;
  currentSongKey = songKey;
}

/* ─────────────────────────────────────────────────────────────────────────────
   Auto-load first song
   ───────────────────────────────────────────────────────────────────────────── */
window.addEventListener('load', ()=>{
  const firstKey = Object.keys(SONGS)[0];
  const firstBtn = document.querySelector('.song-btn');
  if (firstKey && firstBtn) loadSong(firstKey, firstBtn);
});

// ─── Toggle Waveforms ───
const elToggleWave = document.getElementById('toggleWaveBtn');
let waveHidden = false;

elToggleWave.addEventListener('click', () => {
  waveHidden = !waveHidden;
  tracks.forEach(t => {
    if (t._el && t._el.waveWrap) {
      t._el.waveWrap.style.display = waveHidden ? 'none' : 'block';
    }
  });

  // Update button text and highlight
  if (waveHidden) {
    elToggleWave.textContent = 'Waveforms Off';
    elToggleWave.classList.remove('primary'); // remove highlight when off
  } else {
    elToggleWave.textContent = 'Waveforms On';
    elToggleWave.classList.add('primary');    // highlight when on
  }
});
  
</script>
</body>
</html>
